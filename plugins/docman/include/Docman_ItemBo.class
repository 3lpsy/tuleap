<?php
/**
 * Copyright (c) STMicroelectronics, 2006. All Rights Reserved.
 *
 * Originally written by Manuel Vacelet, 2006
 *
 * This file is a part of CodeX.
 *
 * CodeX is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * CodeX is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with CodeX; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * $Id$
 */
require_once('common/dao/CodexDataAccess.class');
require_once('Docman_ItemDao.class');
require_once('Docman_ItemFactory.class');
require_once('common/permission/PermissionsManager.class');

class Docman_ItemBo {
    var $groupId;
    var $dao;

    function Docman_ItemBo($groupId=0) {
        $this->groupId = (int) $groupId;
        $this->dao = new Docman_ItemDao(CodexDataAccess::instance());
    }       

    /**
     * Retreive list of collapsed items for given user
     *
     * This function retreive collapsed folders from user preferences 
     *
     * @param $parentId Id of the "current" root node (cannot be excluded).
     * @param $userId Id of current user.
     * @return Array List of items to exclude for a search
     **/
    function &_getCollapsedUserPrefs($parentId, $userId) {           
        $collapsedItems = array();     
        // Retreive the list of collapsed folders in prefs        
        $dar =& $this->dao->searchCollapseUserPrefs($this->groupId, 
                                                    $userId);
        while($dar->valid()) {
            $row =& $dar->current();
            $tmp = explode('_', $row['preference_name']);
            if ($tmp[4] != $parentId) {
                $collapsedItems[] = (int) $tmp[4];
            }
            $dar->next();
        }               
        
        return $collapsedItems;
    }

    function userHasPermission(&$user, &$item) {
        $pm =& PermissionsManager::instance();
        
        if ($user->isSuperUser() 
            || $pm->userHasPermission($item->getId(), 'PLUGIN_DOCMAN_READ', $user->getUgroups(array())) 
            || $pm->userHasPermission($item->getId(), 'PLUGIN_DOCMAN_WRITE', $user->getUgroups(array())) 
            || $pm->userHasPermission($item->getId(), 'PLUGIN_DOCMAN_MANAGE', $user->getUgroups(array())) 
            || $pm->userHasPermission($item->getId(), 'PLUGIN_DOCMAN_ADMIN', $user->getUgroups(array()))) {
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * Build a subtree from with the list of items
     * 
     * @param $parentId int Id of tree root.
     * @return Item 
     */
    function &getItemSubTree($parentId, $params = null) {
        $_parentId = (int) $parentId;
               
        $user =& $params['user'];

        // {{1}} Exclude collapsed items      
        $excludedItems = array();
        if (!isset($params['ignore_collapse']) 
            || !$params['ignore_collapse']) {
            $excludedItems =& $this->_getCollapsedUserPrefs($_parentId, 
                                                             user_getid());
        }

        // Prepare filters if any
        $filter = null;
        if(isset($params['filter'])) {
            $filter =& $params['filter'];
        }  

        $dar =& $this->dao->searchByGroupId($this->groupId, $filter);
        
        $itemFactory =& new Docman_ItemFactory();

        $parentIdList = array();
        $itemList = array();
        $first = true;
        while(count($parentIdList) > 0 || $first) {
            if(!$first) {
                $dar =& $this->dao->searchByIdList($parentIdList);
            }
            else {
                $first = false;
            }
               
            $tmpParentIdList = array();

            while($dar->valid()) {
                $row =& $dar->current();

                $item =& $itemFactory->getItemFromRow($row);
                if($this->userHasPermission($user, $item)) {
                    $insert = false;
                    $type = $itemFactory->getItemTypeForItem($item);
                    if ($type == PLUGIN_DOCMAN_ITEM_TYPE_FILE 
                        || $type == PLUGIN_DOCMAN_ITEM_TYPE_EMBEDDEDFILE) {
                        // For items with history, we retreive all versions
                        // of the item. The following keep only the more
                        // recent version of the item
                        if(isset($itemList[$item->getId()])) {
                            $oldVer =& $itemList[$item->getId()]->getCurrentVersion();
                            $newVer =& $item->getCurrentVersion();
                            if($oldVer->getDate() < $newVer->getDate()) {
                                $insert = true;
                            }
                        }
                        else {
                            $insert = true;
                        }
                    }
                    else {
                        $insert = true;
                    }

                    if($insert) {
                        $itemList[$item->getId()] =& $item;
                        if($item->getId() != $_parentId) {
                            $tmpParentIdList[] = $item->getParentId();
                        }
                    }
                }
                
                $dar->next();
            }
            
            $parentIdList = array();
            foreach($tmpParentIdList as $id) {
                if(!array_key_exists($id, $itemList) 
                   && !in_array($id, $parentIdList)) {
                    $parentIdList[] = $id;
                }
            }
         }
     
        // Note: use foreach with keys to ensure we only deal with
        // references (foreach $itemList loose references)

        // Build hierarchie
        $keys = array_keys($itemList);
        foreach($keys as $i) {
            if(isset($itemList[$itemList[$i]->getParentId()])) {         
                $itemList[$itemList[$i]->getParentId()]->addItem($itemList[$i]);
            }
        }        
        
        // @todo: Tailor empty folders      

        // Tailor collapsed folders
        $keys = array_keys($itemList);
        foreach($keys as $i) {
            $item =& $itemList[$i];
            if(in_array($item->getId(), $excludedItems)) {
                // @todo: Delete all childrens
                $item->setNbOfChildren(0);
                unset($item->_items);
                $item->_items = array();
            }
            unset($item);
        }

        // If nothing to output, output root (?)
        if(!isset($itemList[$_parentId])) {
            $item =& $this->findById($_parentId);
            if($this->userHasPermission($user, $item)) {
                $itemList[$_parentId] =& $item;
            }
        }

        return $itemList[$_parentId];     
    }

    /**
     *
     */
    function &getItemSubTreeAsList($parentId, $params = null) {
        $_parentId = (int) $parentId;
               
        $user =& $params['user'];

        // Prepare filters if any
        $filter = null;
        if(isset($params['filter'])) {
            $filter =& $params['filter'];
        }

        $itemFactory =& new Docman_ItemFactory();
        $itemList = array();
        $itemLocationInList = array();

        $dar =& $this->dao->searchByGroupId($this->groupId, $filter);
        $i = 0;
        while($dar->valid()) {
            $row =& $dar->current();

            $item =& $itemFactory->getItemFromRow($row);
            if($this->userHasPermission($user, $item)) {
                $insert = false;
                $type = $itemFactory->getItemTypeForItem($item);
                if ($type == PLUGIN_DOCMAN_ITEM_TYPE_FILE 
                    || $type == PLUGIN_DOCMAN_ITEM_TYPE_EMBEDDEDFILE) {
                    // For items with history, we retreive all versions
                    // of the item. The following keep only the more
                    // recent version of the item
                    if(isset($itemLocationInList[$item->getId()])) {
                        $itemOffset = $itemLocationInList[$item->getId()];
                        $oldVer =& $itemList[$itemOffset]->getCurrentVersion();
                        $newVer =& $item->getCurrentVersion();
                        if($oldVer->getDate() < $newVer->getDate()) {
                            $itemList[$itemOffset] =& $item;
                            $insert = false;
                        }
                    }
                    else {
                        $insert = true;
                    }
                }
                else {
                    $insert = true;
                }
                
                if($insert) {
                    $itemLocationInList[$item->getId()] = $i;
                    $itemList[$i] =& $item;
                    $i++;
                }
            }
            unset($item);

            $dar->next();
        }

        return new ArrayIterator($itemList);
    }

    // STOP: note for childrens, this is a big messy hack !
    // this 'else' statement only happend a fake child to a node
    // that contains child but for whom child was not fetched from
    // database. We need to add a fake child to be able to detect
    // this case on display to add a clickable 'plus'.
    function &getParentList() {
        // Fetch list of items that contains that are parent of other items.
        $dar =& $this->dao->searchAllParent($this->groupId);
        $fakeParentList = array();
        while($dar->valid()) {
            $row =& $dar->current();
            $fakeParentList[] = $row['parent_id'];
            $dar->next();
        }

        return $fakeParentList;
    }


    /**
     * Build a tree from with the list of items
     *
     * @return ItemNode
     */
    function &getItemTree($id = 0, $params = null) {
        if (!$id) {
            $id = $this->dao->searchRootIdForGroupId($this->groupId);
        }
        return $this->getItemSubTree($id, $params);
    }

    /**
     * Build a list of items
     *
     * @return ItemNode
     */
    function &getItemList($id = 0, $params = null) {
        if (!$id) {
            $id = $this->dao->searchRootIdForGroupId($this->groupId);
        }
        return $this->getItemSubTreeAsList($id, $params);
    } 

    /**
    * @return Item
    */
    function &findById($id, $params = array()) {
        $item_factory =& $this->_getItemFactory();
        $item =& $item_factory->getItemFromDb($id);
        if (is_a($item, 'Docman_Folder') && isset($params['recursive']) && $params['recursive']) {
            $item =& $this->getItemSubTree($item->getId(), $params);
        }
        return $item;
    }
    var $item_factory;
    function &_getItemFactory() {
        if (!$this->item_factory) {
            $this->item_factory =& new Docman_ItemFactory();
        }
        return $this->item_factory;
    }
}

?>